## 事务隔离级别
### 什么是事务
事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务最经典也最经常被拿出来说的例子就是转账了。假如小明要给小红转账1000元，这个转账会
涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一两个操作
之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。
事务就是保证这两个关键操作要么都成功，要么都失败。

### 事务的特性(ACID)
* 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
* 一致性：执行事务前后，数据库保持一致，例如转账业务中，无论事务是否成功，转账人和收款人的总额应该是不变的。
* 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
* 持久性：一个事务被提交之后，它对数据库的改变是持久的，即使数据库发生故障也不应对其有任何影响。
### 并发事务带来的问题
在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务(多个用户对统一数据进行操作)。并发虽然是
必须的，但可能会导致以下问题。
* 脏读(Dirty read):当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务
也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是"脏数据",依据
脏数据所做的操作是不正确的。
* 丢失修改(Lost to modify):指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个
数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此也被称为丢失修改。例如：事务1读取某表中
的数据A=20,事务2也读取A=20，事务1修改A=A-1,事务2也修改A=A-1,最终结果A=19,事务1的修改被丢失。
* 不可重复读(Unrepeatableread):指在同一个事务内多次读取同一数据。这个事务还没有结束时，另一个事务也访问该数据。
那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了在一个
事务内两次读到的数据是不一样的情况，因此称为不可重复读。
* 幻读(Phantom read):幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据，接着另一个并发事务(T2)插入了一些
数据时，在随后的查询中，第一个事务(T1)就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
**不可重复读和幻读区别：**
不可重复读的重点是修改，幻读的重点在于新增或者删除。

**例1(同样的条件，你读取过的数据，再次读取出来发现值不一样了)：** 事务1中的A先生读取自己的工资为1000的操作还没
完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变成了2000；这就是不可重复读。

**例2(同样的条件，第一次和第二次读出来的记录数不一样)：** 假如某工资单表中工资大于3000的有4人，事务1读取了所有
工资大于3000的人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，
这样就导致了幻读。

### 事务隔离级别
SQL标准定义了四个隔离级别：
* READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
* READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读和不可重复读仍有可能发生。
* REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务所修改，可以阻止脏读和不可
重复读，但幻读仍有可能发生。
* SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不
可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。


