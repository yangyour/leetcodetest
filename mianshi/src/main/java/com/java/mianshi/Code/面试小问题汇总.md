##如何实现数组和List之间的转换？
* List转换为数组：调用ArrayList的toArray方法
* 数组转换为List：调用Arrays的asLsList()方法。
## Array和ArrayList有何区别？
* Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
* Array是指定大小的，而ArrayList大小是固定的。
* Array并没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等
## 并行与并发有什么区别？
* 并行是指两个或多个事件在同一刻发生；而并发是指两个或多个事件在同一时间间隔发生。
* 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
* 在一台机器上"同时"处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。
## 创建线程有哪几种方式？
1. 继承Thread类创建线程类
    * 定义Thread的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
    * 创建Thread子类的实例，即创建了线程对象。
    * 调用线程对象的start()方法来启动线程。    
2. 通过Runnable接口创建线程类
    * 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
    * 创建Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    * 调用线程对象的start()方法来启动线程。
3. 通过Callable和Future创建线程
    * 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
    * 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()
    方法的返回值。
    * 使用FutureTask对象作为Thread对象的target创建并启动新线程。
    * 使用FutureTask对象的get()方法来获得子线程执行结束后的返回值。
## 线程有哪些状态？
线程通常有5种状态，创建、就绪、运行、阻塞和死亡。
* 创建状态：在生成线程对象，并没有调用该对象的start方法，这时线程处于创建状态。
* 就绪状态：当调用了线程对象的start()方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，
此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
* 运行状态：线程调度程序处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
* 阻塞状态：线程在运行的时候，被暂停，通常是为了等待某个时间的发生(比如某项资源就绪)之后再继续运行。sleep，suspend，wait
等方法都可以导致线程阻塞。
* 死亡状态：如果一个线程的run()方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法
令其进入就绪。