## 1.写在前面
> 本文主要针对Hotspot VM中"CMS+ParNew"组合的一些使用场景进行总结。
>重点通过部分源码对根因进行分析以及对排查方法进行总结，排查过程会省略较多，
>另外本文专业术语较多，有一定的阅读门槛，如未介绍清楚，还请自行查阅相关资料。
### 1.1 引言
自Sun发布Java语言以来，开始使用GC技术来进行内存自动管理，避免了手动管理带来的
悬挂指针(Dangling Pointer)问题，很大程度上提升了开发效率，从此GC也一举
成名。GC有着非常悠久的历史，1960年有着"Lisp"和"人工智能之父"之称的John
McCarthy就在论文中发布了GC算法，60年以来，GC的技术发展也突飞猛进，但不管
是多么前沿的收集器也都是基于三种基本算法的组合或应用，也就是说GC要解决的根本
问题这么多年一直都没有变过。笔者认为，在不久的将来，GC技术仍然不会过时，比起
日新月异的新技术，GC这门古典技术更值得我们学习。

目前，互联网上JAVA的GC资料要么是主要讲理论，要么就是针对单一场景的GC问题进行
了剖析，对整个体系总结的资料少之又少。前车之鉴，后事之师，美团的几位工程师
收集了内部各种GC问题的分析文章，并结合个人的理解做了一些总结，希望能起到
"抛砖引玉"的作用，文中若有错误之处，还请大家不吝指正。

GC问题处理能力能不能系统性掌握？一些影响因素都是**互为因果**的问题该怎么分析？
比如一个服务RT突然上涨，还有GC耗时增大、线程Block增多、慢查询增多、CPU
负载高四个表象，到底哪个是诱因？如何判断GC有没有问题？使用CMS有哪些常见
问题？如何判断根因是什么？如何解决或避免这些问题？阅读完本文，相信你将会
对CMS GCD的问题处理有一个系统性的认知，更能游刃有余地解决这些问题，下面
我们就开始吧！
### 1.2 概览
想要系统性的掌握GC问题处理，笔者这里给出一个学习路径，整体文章的框架也是
按照这个结构展开，主要分为四大步。
![](https://p1.meituan.net/travelcube/1f6c3ec0209f4d9406e1925445bfa86039288.png)
* 建立知识体系：从JVM的内存结构到垃圾收集的算法和收集器，学习GC的基础知识，
掌握一些常用的GC问题分析工具。
* 确定评价指标：了解基本GC的评价方法，摸清如何设定独立系统的指标，以及在
业务场景中判断GC是否存在问题的手段。
* 场景调优实验：运用掌握的知识体系和系统评价指标，分析与解决九种CMS中常见
GC问题场景。
* 总结优化场景：对整体过程做总结并提出笔者的几点建议，同时将总结到的经验
完善到知识体系之中。
## 2.GC基础
在正式开始之前，先做些简要铺垫，介绍下JVM内存划分、收集算法、收集器等常用
概念介绍。
### 2.1 基础概念
* **GC:** GC本身有三种语义，下文需要根据具体场景带入不同的语义：
    * **Garbage Collection：** 垃圾收集技术，名词。
    * **Garbage Collector:** 垃圾收集器，名词。
    * **Garbage Collecting：** 垃圾收集动作，动词。
* **Mutator：** 生产垃圾的角色，也就是我们的应用角色，垃圾制造者，通过
Allocator 进行 allocate 和 free
* **TLAB** Thread Local Allocation Buffer的简写，基于CAS的独享
线程(Mutator Threads)可以优先将对象分配在Eden中的一块内存，因为是JAVA
线程独享的内存区所以没有锁竞争，所以分配速度更快，每个TLAB都是一个线程独享的
* **Card Table：** 中文翻译为卡表，主要是用来标记卡页的状态，每个卡表
项对应一个卡页。当卡页中一个对象引用有写操作时，写屏障将会标记对象所在的卡表
状态改为dirty，卡表的本质是用来解决跨代引用的问题。具体怎么解决的可以参考
StarkOverflow上的这个问题[how-actually-card-table-and-writer-barrier-works](how-actually-card-table-and-writer-barrier-works),
或者研读一下cardTableRS.app中的源码。    

### 2.2 JVM内存划分
从JCP(Java Community Process)的官网中可以看到，目前Java版本最新已经到了Java16，未来的Java
17以及现在的Java11和Java8是LTS版本，JVM规范也在随着迭代在变更，由于本文主要讨论CMS，此处还是
放Java8的内存结构。
![](https://p0.meituan.net/travelcube/132ba6ba720f2bfc6c69b1ce490f7c87693987.jpg)
GC主要工作在Heap区和MetaSpace区(上区蓝色的部分)，在Direct Memory中，如果使用的是DirectByteBuffer，
那么在分配内存不够时则是GC通过`Cleaner#clean`间接管理。任何自动内存管理系统都会面临的步骤：为新
对象分配空间，然后收集垃圾对象空间，下面我们就展开介绍一下这些基础知识。

### 2.3 分配对象
Java中对象地址操作主要使用Unsafe调用了C的allocate和free两个方法，分配方法有2种:
* **空闲链表(free list)：**